#!/usr/bin/python
# -*- coding: utf8 -*-

# Function Call Graph dependency plotter
# Marcus Botacin - UFPR - 2018

import sys                   # Read Input
import pygraphviz as pgv     # Plot Graph

# Plotter Class
class Plotter():
    # requires input and output file names
    def __init__(self,input=None,output=None):
        # init variables
        self.__stack=[]         # Match brackets to identify functions
        self.__functions=set()  # Identified function names
        self.__current="Entry"  # First Tree level
        # declare graph
        self.__Graph=pgv.AGraph(directed=True)

        # try to generate file names
        try:
            self.__f = input
            self.__dot = "%s.dot" % output
            self.__eps = "%s.eps" % output
        except:
            # raise error in case of
            raise ValueError("Input/Output files error")

    # plot method
    def plot(self):
        # first parse the source files
        # and save the parse data
        # it is required for our 2-phase processing
        self.__parse_input()
        # First pass to identify function names
        self.__identify_functions()
        # second pass to identify which function calls each one
        self.__identify_relations()
        # then plot the graph
        self.__save()

    # Parse file
    def __parse_input(self):
        # currently, i'm assuming a single file with all functions
        f=open(self.__f,"r")
        # then I just read and split
        self.__lines = f.read().split("\n")

    # identify function name within an statement
    def __get_func_name(self,func):
        # assuming POO in C++
        if "::" in func:
            return func.split("::")[1].split("(")[0]
        # non-classes methods
        else:
            return func.split("(")[0].split(" ")[-1]

    # First pass implementation
    def __identify_functions(self):
        # traverse the whole file
        for i,line in enumerate(self.__lines):
            l = line.strip()
            # if open brackets
            if "{" in l:
                # and current stack is empty, probably a new function was declated
                if len(self.__stack)==0:
                    # then consider its name
                    self.__functions.add(self.__get_func_name(self.__lines[i-1]))
                # and add the bracket to the stack
                self.__stack.append("{")
            # match closing brackets to opening ones
            # as this is an easy way to identify function declarations
            if "}" in l:
                # remove from stack
                # assuming a single } per line
                self.__stack.pop()

    # Second pass implementation
    def __identify_relations(self):
        # traverse source file as previously described
        for i,line in enumerate(self.__lines):
            l = line.strip()
            if "{" in l:
                if len(self.__stack)==0:
                    # get current function name
                    # used as graph node
                    current=self.__get_func_name(self.__lines[i-1])
                self.__stack.append(current)
            if "}" in l:
                self.__stack.pop()
            # entries which are neither { nor }
            # basically functions' contents
            if len(self.__stack)!=0:
                # check if some function name is a substring of current statement
                for f in self.__functions:
                    if f in line:
                        # debug
                        if __debug__:
                            print(current,f)
                        # edge from one function to its dependency
                        self.__Graph.add_edge(current,f)  

    # save graph to files
    def __save(self):
        # RAW dot file
        self.__Graph.write(self.__dot)
        # set layout to dot
        self.__Graph.layout('dot')
        # and plot vectorial graph
        self.__Graph.draw(self.__eps)

# Usage Message
def usage(binary_name):
    print("Usage: python %s <input> <output>" % binary_name)

# Direct Call
if __name__ == '__main__':
    # Requires input and output
    if(len(sys.argv)!=3):
        # print usage if params not supplied
        usage(sys.argv[0])
    # otherwise, instantiate plotter
    p = Plotter(sys.argv[1],sys.argv[2])
    # and plot
    p.plot()
