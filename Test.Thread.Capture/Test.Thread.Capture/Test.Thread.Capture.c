/* MultiCore malware project
 * Simple driver to capture threads data
 * Marcus Botacin - 2017
 * Federal University of Paraná (UFPR)
*/

/* Include block */
#include <fltKernel.h>
#include <ntstrsafe.h>
#include <dontuse.h> 
#include <suppress.h>
#include<ntifs.h>

#define REGCallbackALTITUDE L"388990" /* Altitude Number, blame MS , not me */
LARGE_INTEGER cookie; /* callback cookie */

/* Unload routine */
VOID DriverUnload(PDRIVER_OBJECT Driverobject)
{
	UNREFERENCED_PARAMETER(Driverobject);
	/* unregister callback */
	CmUnRegisterCallback(cookie);
	/* nothing to free */
	DbgPrint("Unloading\n");
}

/* max string */
#define MAX 2048

/* Registry Callback */
NTSTATUS RegCallback(PVOID Contexto,REG_NOTIFY_CLASS Arg1,PVOID Arg2)
{
	HANDLE pid;
	HANDLE tid;
	char msg[MAX];
	UNREFERENCED_PARAMETER(Contexto);
	UNREFERENCED_PARAMETER(Arg1);
	UNREFERENCED_PARAMETER(Arg2);
	/* Get Process Id */
	pid=PsGetCurrentProcessId();
	/* Get Thread Id */
	tid=PsGetCurrentThreadId();
	/* Display data */
	sprintf_s(msg,MAX,"PID %x TID %x",pid,tid);
	DbgPrint(msg);
	return STATUS_SUCCESS;
}

/* Driver Entry */
NTSTATUS
DriverEntry (
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PUNICODE_STRING RegistryPath
    )

{
	UNICODE_STRING straltitude;
    NTSTATUS status=STATUS_SUCCESS; /* OK, I guess it will suceed */
	UNREFERENCED_PARAMETER(RegistryPath); /*No Use. You may want to take a copy of the mount point, but i don't */
	
	/* Register unload routine */
	DbgPrint("Driver running\n");
	DriverObject->DriverUnload=DriverUnload; /*Set The Unload Routine */
		
	/* Register callback */
	RtlInitUnicodeString(&straltitude,REGCallbackALTITUDE);
	status = CmRegisterCallbackEx((PEX_CALLBACK_FUNCTION)RegCallback,&straltitude,DriverObject,NULL,&cookie,NULL);
	if(!NT_SUCCESS(status))
	{
			CmUnRegisterCallback(cookie);
	}

    return status;
}